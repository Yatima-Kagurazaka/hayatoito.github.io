<!DOCTYPE html>
<html>
  <head>
    <title>Data Structures and Algorithms in Chrome — hayato.io</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">

    <link href="https://plus.google.com/+HayatoIto/posts" rel="author">

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.rawgit.com/afeld/bootstrap-toc/v0.4.1/dist/bootstrap-toc.min.css">

    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link href="https://hayato.io/theme/solarizedlight.css" rel="stylesheet">
    <link href="https://hayato.io/theme/site.css" rel="stylesheet">

    <link id="favicon" href="https://hayato.io/favicon.ico" rel="shortcut icon">

    <link href="https://hayato.io/feeds/all.atom.xml" rel="alternate"
          title="All posts – hayato.io" type="application/atom+xml">

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-195971-6', 'hayato.io');
  ga('send', 'pageview');
</script>


    <rdf:RDF
        xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
        xmlns:dc="http://purl.org/dc/elements/1.1/"
        xmlns:foaf="http://xmlns.com/foaf/0.1/">
      <rdf:Description rdf:about="https://hayato.io/drafts/data-structures-and-algorithms-in-chrome/">
        <foaf:maker rdf:parseType="Resource">
          <foaf:holdsAccount>
            <foaf:OnlineAccount foaf:accountName="hayatoito1">
              <foaf:accountServiceHomepage rdf:resource="http://www.hatena.ne.jp/" />
            </foaf:OnlineAccount>
          </foaf:holdsAccount>
        </foaf:maker>
      </rdf:Description>
    </rdf:RDF>
    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
  </head>
  <!-- http://afeld.github.io/bootstrap-toc/ -->
  <body data-spy="scroll" data-target="#toc">
    <nav class="navbar navbar-default" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="fa fa-collapse icon-2x"></span>
          </button>
          <a href="https://hayato.io/" class="navbar-brand">hayato.io</a>
        </div>
        <div class="collapse navbar-collapse">
          <ul class="nav navbar-nav">
            <li><a href="https://hayato.io/archives/"><i class="fa fa-list"></i>&nbsp;Archives</a></li>
          </ul>
        </div>
      </div>
    </nav>
    <div class="container">
      <div class="row">
        <div class="col-md-9">
<article>
  <header class="page-header">
    <h1 class="site-article-title">
      Data Structures and Algorithms in Chrome
    </h1>
    <div class="text-right">
      Hayato Ito
    </div>
    <div class="text-right">
      <time datetime="2017-12-24">
        2017-12-24
      </time>
    </div>
  </header>
  <div class="article-content">
    <p>これは <a href="https://qiita.com/advent-calendar/2017/chromium">Chromium Browser アドベントカレンダー</a>の24日目の記事です。</p>
<p>この記事の筆者は、現在、Chrome - DOM/HTML Team の Tech Lead です。本人が関わっているところを中心に書きますね。</p>
<p>この記事の一部は、Chromium の Git レポジトリ内に存在す
<a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/WebKit/Source/core/dom/README.md">Source/core/dom/README.md</a>
（英語） が元になっていますが、想定読者をWeb開発者に含めて、大幅にわかりやすく加筆修正しています。元々の README.md を書いたのも私ですので、翻訳の許可を取る必要がありません。:)</p>
<h1 id="tree">Tree</h1>
<h2 id="dom">DOM</h2>
<p>DOM は Web の基本です。いってみれば、Webを構成する原子のようなものです。</p>
<p><img alt="dom" src="/assets/2017/dom.svg"></p>
<p>個々の DOM Object は一般に Node (ノード)と呼ばれます。
たとえば、みなさんが今現在見ているこの記事を、ブラウザ内では、約XXXX個のDOM Objectが生成されます。</p>
<p>ブラウザの Developer Console 等から、記事が、何個のノードが存在するか確認できます。</p>
<div class="highlight"><pre><span></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">).</span><span class="nx">length</span><span class="p">);</span>
</pre></div>


<p><img alt="many dom" src="/assets/2017/many-dom.svg"></p>
<div class="article-info">
これは Document Tree の ノードしか数えていません。実際は「隠された」DOMが多く存在します。後ほど説明します。
</div>

<p>DOM はばらばらに存在していません。ブラウザ内部では、階層構造・Tree (木)を構成します。</p>
<p><img alt="node tree" src="/assets/2017/node-tree.svg"></p>
<p>例: たとえば、以下のようなHTMLが与えられたとき、</p>
<div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">link</span> <span class="na">style</span><span class="o">=</span><span class="s">&#39;hello.css&#39;</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>hello<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>world<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</pre></div>


<p>ブラウザは、HTML を以下のような Node Tree をつくります。</p>
<p><img alt="node tree example" src="/assets/2017/node-tree-example.svg"></p>
<h2 id="node-chrome-dom-tree">Node (ノード) / Chrome での DOM Tree の実装</h2>
<p>Tree はコンピュータ・サイエンスにおいて頻出するデータ構造です。ですが、Tree をどのように実装するかは状況によって異なります。</p>
<p>例えば、</p>
<ul>
<li>親ノードへのポインタは必要ないので持たない。</li>
<li>親ノードにはすべての子ノードへのポインタを持たせる。</li>
</ul>
<p>等が実装パターンとしてあります。</p>
<p>Chrome の DOM Tree の実装は以下のようになってります。</p>
<p>ノード は親ノードへのポインタをもっています。</p>
<p><img alt="parent" src="/assets/2017/parent.svg"></p>
<p>子ノードに対しては、全ノードへのポインタはもっていません。２つだけ、firstChild (最初の子供), lastChild (最後の子供）へのポインタをもっています</p>
<p><img alt="firstChild and lastChild" src="/assets/2017/first-child.svg"></p>
<div class="article-info">
firstChild, lastChild は Node クラスではなく、Node クラスを継承した ContainerNode クラスに定義されています。
例えば、子供を持つことができない、末端の Node である Text Node (テキストノード) などは、このようなポインタを持つ必要がありません。
以下は、この違いを無視して、すべて Node として扱います。
</div>

<p>その代わり、各ノードは、Sibling (兄弟)ノードへのポインタ、previous sibling と next sibling をもっています。</p>
<p><img alt="next sibling and previous sibling" src="/assets/2017/next-sibling.svg"></p>
<p>これが意味することをまとめると:</p>
<ul>
<li>標準で用意されている DOM API の大部分は、定数時間 O(1)で実装可能です。</li>
</ul>
<div class="article-danger">
`parentNode.append(child)`, `chilNdode.before(node)`, `childNode.remove()` 等。Chrome 開発者になったとして、これらの実装を考えてみましょう。O(1) で可能でしょうか？
</div>

<ul>
<li>ノードの子供は、Linked List (リンクドリスト） として実装されています。つまり、n番目の子供にアクセスするには、O(n) の時間がかかります。
  また親ノードは子ノードの数は直接もっていません。つまり、子ノードの数を知るには、リンクドリストをすべて辿らないといけません。O(n) かかります。</li>
</ul>
<p>以下のコードは、O(N)ではなく、O(N^2) 時間がかかる可能性があります。それはなぜでしょうか？</p>
<div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">countNodes</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">parentNode</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">++</span><span class="nx">count</span><span class="p">;</span>
    <span class="kr">const</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">parentNOde</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="c1">// ...</span>
    <span class="nx">count</span> <span class="o">+=</span> <span class="nx">traverseTree</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">countNodes</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">));</span>
</pre></div>


<div class="article-danger">
countNodes() を改良して、O(n) で全ノードをトラバースする関数を書いてみましょう。
得られたノード数は、querySelectorAll(*).length と違いはあるでしょうか？
</div>

<div class="article-info">
<p><b>Chrome開発者へ</b></p>

あなたがChromeの開発者ならば、このように手作業でノードをトラバースする必要はありません。
Chrome内部では、NodeTraversal, ElementTraversalを使用しましょう。

これらの便利ファンクションは、ゼロコスト抽象化に基づいて実装されています。
すべてのテンプレートはインライン化されますので、余分なオーバーヘッドがありませんので、安心して使用してください。
</div>

<div class="article-info">
<p><b>Microsoft Edgeについて</b></p>

ほとんどのモダンブラウザでは、DOM は、ブラウザ内部ではそのまま Tree で表現されます。
しかし、Microsoft Edge はこれまでそうではありませんでした。Edge はいわゆる Word などの文書プロセッサが採用するXXX データ構造を採用
していました。Shadow DOM の実装。
</div>

<h1 id="hashmap">HashMap (ハッシュマップ)</h1>
<p>ブラウザは、よくある操作に素早く答えるため、Tree に付随するデータ構造をもっています。</p>
<p>たとえば <code>getElementById(xx)</code> は 指定された id を持つエレメント(例: <code>&lt;div id=xx&gt;</code>)を返す DOM APIですが、この関数が呼ばれるために、
毎回ブラウザは、ツリーをトラバースして、指定されたidをもつノードを探すわけではありません。</p>
<p>ブラウザは、id と ノードの対応表を別途持っており、それを常にアップデートすることで、これらのDOM Apiは定数時間 O(1)で可能です。</p>
<p><img alt="id to element mapping" src="/assets/2017/id2element.svg"></p>
<p>これはほんの一例であり、その他にもたくさんのデータ構造・キャッシュがあります。
ただし、いたずらになんでもデータ構造を用意すればよいというものではなく、時間と空間のトレードオフについては常に慎重です。
Node Tree の構造は常にアップデートされうるため、これらの付随するデータもアップデートする実行時のコスト、や
これらのデータが常に最新状態を反映するように気をつけなければいけません。
それらはChrome 開発者自身が払わなければいけないコードのメンテナンスコスト</p>
<div class="article-info">
<p><b>id が複数ある場合</b></p>
同じ id をもつ、エレメントが複数ある場合は、あまり知られていませんが、Tree Order の順番で最初に見つかるものが優先されます。
そのため、実際は、idとエレメントの対応表は、単純な HashMap ではなく、TreeScopeOrderedMap で管理しています。

Tree-Oder とはいわゆる深さ優先探索でノードを訪れる順番です。DOM や HTML 仕様ではよく使用されます。
</div>

<p><img alt="tree order" src="/assets/2017/tree-order.svg"></p>
<div class="article-info">
<p><b>getElementById(xx) vs querySelector('#xx')</b></p>

querySelector('#xx') は getElementById(xx) と同じ動作になります。querySelector の場合は、任意のCSSセレクタがパラメータとして
渡りうるので、一見、getElementById(xx) より遅いと思われるかもしれません。

実際は、querySelector('#xx') は getElementById(xx) とほぼ同じ速度で動作します。

このように非常によくあるケースでは、ブラウザは内部で shortcut を用意して、通常のCSS Selector マッチングの処理ではなく、特別なショートカットパスに移ることはよくあります。

querySelector は渡された CSS セレクタが '#id' の形式であることが判明しだい、...。

この手の「ショートカット」はありとあらゆるところにいれています。
</div>

<p><img alt="short cut" src="/assets/2017/query-selector.svg"></p>
<h1 id="super-tree">Super Tree (スーパーツリー: すっごい木)</h1>
<p>ここまでは、従来の Web でした。この状況は、Shadow DOM の出現とともに、がらりと様子を変えることになります。</p>
<p>Shadow DOM の詳細は、とても、この記事では、書ききれないので、興味がある人は、私に直接あった時に聞いてください。
ここではできるだけ簡潔に述べます。</p>
<p>条件を満たすすべてのエレメントは、内部に 別の Node Tree をホストできるようになりました。</p>
<p>わかりやすく言うと、いままで Web の世界を構成する最小構成単位であった、エレメント（原子）自身が、その内部に、もうひとつの世界をもつことができるようになります。</p>
<p><img alt="shadow tree" src="/assets/2017/shadow-tree.svg"></p>
<p>内側の世界と外側の世界には、本質的な違いは存在しません。そのため、内側の世界の各エレメントも、それぞれ内部にもうひとつの世界をもつことができます。この世界は何段にもネストできます。</p>
<p><img alt="super tree" src="/assets/2017/super-tree.svg"></p>
<p>つまり Modern Web においては、世界は、ノードのツリーから、構成されるのではなく、ノードツリーのツリーから構成されます。
あなたがつくっている世界は、実は、他の世界のほんの一部分にしかしぎないかもしれませんし、
あなたが利用しているエレメントの内部には、実は膨大な世界が広がっているかもしれません。
それを意識する必要はありません。</p>
<div class="article-info">
<p><b>Shadow DOM の実装状況</b></p>

Chrome, Safari はすでに実装済み。Firefox も現在実装中です。
</div>

<p>たとえば、<code>&lt;video&gt;</code> エレメント等は、実は、Chrome では Shadow DOM でできています。
Web 開発者は、<code>&lt;video&gt;</code> エレメントの中にもうひとつの世界が広がっていることを知る必要もなく、利用していますが、</p>
<p>他にも、<code>&lt;input&gt;</code> エレメントなども、内部は、Shadow Tree で実装されています。</p>
<p><img alt="video element" src="/assets/2017/video-element.svg"></p>
<p>さきほど、#id 等は、それぞれの</p>
<p>Chrome においては、それぞれの ツリーのルートである、Document と ShadowRoot はそれぞれ、共通の TreeScope を実装しており、
TreeScope 内に、</p>
<p>これは、#id だけではなく、たとえば、CSS の セレクトなどもそうです。それぞれの TreeScope 内に適用範囲が限定されるため、
サーチやマッチングの対象を自ツリーだけに限定することができます。</p>
<p><img alt="tree scope" src="/assets/2017/tree-scope.svg"></p>
<p>Tree が異なれば、id がかぶってもOK! 自分のツリー内のことだけ考えればいいよ！</p>
<div class="article-info">
<p><b>Divide and Conquer: 分割統治</b></p>

ある複雑な問題を解くときに、分割して統治するのは、ソフトウェア・エンジニアリングに限らず、一般のサイエンス・エンジニアリングの
基本中の基本です。

例えば、TODO


</div>

<p>CSS のセレクタの話がでてきたので、次は、CSS の Selector がどのように実装されているか。</p>
<h1 id="css">CSS</h1>
<p>CSS Selector の ルールは、Chrome では、Linked List として、表現しています。</p>
<div class="highlight"><pre><span></span><span class="nt">a</span> <span class="nt">b</span> <span class="p">.</span><span class="nc">foo</span> <span class="p">{</span>
  <span class="k">color</span><span class="p">:</span> <span class="kc">red</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p><img alt="css selector" src="/assets/2017/css-selector.svg"></p>
<p>直感に反して、左右が逆であることに注意してください。Chrome 内部では、CSS Selector は、Right-to-Left (右から左）の順番で
Linked List を構成します。両方向ではなく、片方向です。</p>
<p>実際の CSS セレクタマッチングでも、セレクタの右から左の順番でルールとエレメントのマッチングを行っています。</p>
<p><img alt="css selector matching" src="/assets/2017/css-selector-matching.svg"></p>
<p>CSS セレクタは、Right-to-Left、エレメントは 基本的には Bottom-to-Top の順番でマッチングを試みています。
このように、愚直にマッチングしていると、バックトラックが何度も発生して、指数関数時間と思われるかもしれませんが、実際は、
数々の最適化・ヒューリスティクスなルールで、現実時間で収まるようになっています。</p>
<p>そのうちのひとつ、Bloom Filter をここでは紹介します。</p>
<h1 id="bloom-filter">Bloom Filter</h1>
<p>Bloom Filter は確率的アルゴリズムです。</p>
<p>例: Bloom filter used in CSS Selector matching</p>
<div class="article-info">
<p><b>オーバーフローを気にしない。</b></p>

例: 手抜きアルゴリズム / Cascading overflow: id class
  少しの意図的な悪いサイトのために、善良なよいサイトがパフォーマンスのペナルティを受ける必要はない。
  ある特定のベンチマークのスコアを伸ばすために、普通な善良なサイトがペナルティを受けるなら、それには反対します。
</div>

<div class="article-danger">
<p><b>宿題: Hack the CSS engine</b></p>
ノード数 100、スタイルシートのサイズ1KB という条件で、ブラウザが固まるような、Node Tree の構造、CSS の ルールセットをつくることは可能でしょうか？何をすれば悪意のあるブラウザの裏をつくようなCSSルールが記述できますか？
</div>

<div class="article-danger">
<p><b>宿題: CSS is Turing Complete?</b></p>
CSS だけで任意の計算が可能でしょうか？ CSSだけでJavaScriptのエミュレータが書けますか？
</div>

<h1 id="event">Event (イベント)</h1>
<p>一部の Event (composed evenet) は、Super Tree を兼ね抜けます。</p>
<p><img alt="event dispatch" src="/assets/2017/event-dispatch.svg"></p>
<p>ただし、カプセル化を壊さないように、たとえ、そのイベントが下の世界（Shadow Tree)で起きたとしても、
あたかも、自分の世界 (Light Tree) で起きたかのように、見せます。</p>
<p>たとえば、<code>&lt;video&gt;</code> element の shadow tree のどこかのノードがクリックされたとします。
<code>&lt;video&gt;</code> element のユーザーは、</p>
<div class="article-info">
Event がどのような、パスを通って来たかを見るには、Event.composedPath() が使用できます。
</div>

<p>また、一部のイベントにおいては、そもそも上の世界に伝える必要がありません。たとえば、ユーザーがマウスを、<code>&lt;video&gt;</code> elemenet の shadow trre の あるノードA から あるノードBに動かしたとします。
このとき、<code>&lt;video&gt;</code> element の実装者は、この <code>mousemove</code> イベントを拾いたいと思うかもしれません。しかし、<video> elemenet のユーザーからみれば、マウスは video element の中からでていません。
上の世界からは、あくｋまで同じエレメント内をマウスが移動しているだけですので、イベントは起きてほしくないでしょう。</p>
<p><img alt="event related" src="/assets/2017/event-dispatch-related.svg"></p>
<p>例: Event (イベント)</p>
<p>イベントのリターゲティングと呼んでいます。
イベントのリターゲティングを、素早く行うためには、ツリー上での親子関係を判断する必要がでてきます。</p>
<p>以下の問題を素早く解く必要があります。</p>
<p>例えば、A は B の先祖ｄしょうか？
という問に答えるためには、どのようにすればよいでしょうか？</p>
<p><img alt="ancestor" src="/assets/2017/ancestor.svg"></p>
<div class="article-info">
ここでは、あたかも Node Tree 上で親子関係を判断している絵になっていますが、実際のChromeでは、Super Tree 上での Tree 同士の親子関係で判断しています。
Super Tree を使用することで、大幅に計算量を削減できる例です。
</div>

<p>普通に実装するならば、</p>
<p>これは、O(N) かかります。</p>
<p>実は、ちょっとの工夫で、これらの問いに定数時間で答えることができるようになります。</p>
<p>Tree の各ノードに以下のように、番号をつけることにしましょう。</p>
<p><img alt="pre post order" src="/assets/2017/pre-post-order.svg"></p>
<p>これらの２つの番号を利用すれば、A は、B の先祖でしょうか？ という問には、</p>
<div class="highlight"><pre><span></span>A.pre &lt; B.pre &amp;&amp; B.pose &lt; A.post
</pre></div>


<p>の条件をチェックするだけで済むことがわかります。これは定数時間 O(1) で。</p>
<div class="article-info">
<p><b>最適化する価値</b></p>

 How much saved? 1K events x 100000 PV * xxx. =
</div>

<h1 id="rendering">Rendering (レンダリング)</h1>
<p>Super Tree はそのままでは、レンダリングできません。
「Tree の Tree」 をひとつの「Tree」に合成する必要があります。そのことを 「Flattening （平らにすること）」と呼んでいます。
レイアウトのために、「Flat」化された Tree は、Flat Tree （フラットツリー）と呼ばれます。</p>
<p><img alt="pre post order" src="/assets/2017/flat-tree.svg"></p>
<p>詳細なアルゴリズムは、ここでは省きますが、実際は、<code>&lt;slot&gt;</code> element を通じて、Light Tree (相対的に外側のTree) と Shadow Tree (相対的に内側のTree)は、レイアウト時には「混ざる」</p>
<h2 id="dynamic-programming">ケーススタディ: Dynamic Programming (動的計画法)</h2>
<p>ひとついえることは、現在、Chrome は Flat Tree はメモリ上には物理的に保持していません。Flat Tree はあくまでコンセプト上のヴァーチャルなツリーであり、レイアウト時に仮想的に作成されます。</p>
<div class="article-info">
<p><b>Shadow DOM is Monad。</b></p>
Shadow DOM が モナドであるという恐ろしい証明に私は成功しましたが、その証明を書くにはここは余白が狭すぎます。
</div>

<div class="article-info">
<p><b>Incremental Shadow DOM</b></p>

現在、Flat Tree を作り方を根本的に改善するため、新しい魔法 (Incremental Shadow DOM)を開発中です。
</div>

<div class="article-info">
<p><b>DOM is Slow</b></p>

- [ ] DOM is slow
- [ ] Lazy Evaluation
  - Style, Computed Style
  - Incremental Shadow DOM
</div>

<h1 id="_1">まとめ</h1>
<p>本記事では、主に、私が開発しているる部分、DOM / Shadow DOM / CSS / Flat Tree 等で使用されているデータ構造とアルゴリズムについて紹介しました。紹介した部分はほんの一部です。</p>
<p>明日、 <a href="https://qiita.com/advent-calendar/2017/chromium">Chromium Browser アドベントカレンダー</a>の25日目、最後の記事では、
「超上流工程から超下流工程」までと、実際の Web の仕様を決めるところから、Chrome に実際にコードを書くところまで、一通り紹介します。</p>
  </div>
</article>

          <footer class="base-footer text-center">
            <small>
              <a href="/">Home</a> | &copy; 2005-2017 hayato.io
            </small>
          </footer>
        </div>
        <div class="col-md-3">
        </div>
      </div>
    </div>
    <script src="https://code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
    <script src="https://hayato.io/theme/site-bundle.js"></script>
    <script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v0.4.1/dist/bootstrap-toc.min.js"></script>
  </body>
</html>